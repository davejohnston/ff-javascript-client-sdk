{
  "version": 3,
  "sources": ["../src/index.ts", "../src/types.ts", "../src/utils.ts"],
  "sourcesContent": ["import jwt_decode from 'jwt-decode'\nimport mitt from 'mitt'\nimport { EventSourcePolyfill } from 'event-source-polyfill'\nimport type {\n  Options,\n  Target,\n  StreamEvent,\n  EventCallback,\n  Result,\n  Evaluation,\n  VariationValue,\n  MetricsInfo\n} from './types'\nimport { Event } from './types'\nimport { logError, defaultOptions, METRICS_FLUSH_INTERVAL } from './utils'\n\nconst SDK_VERSION = '1.3.7'\nconst METRICS_VALID_COUNT_INTERVAL = 500\nconst fetch = globalThis.fetch\nconst EventSource = EventSourcePolyfill\n\n// Flag to detect is Proxy is supported (not under IE 11)\nconst hasProxy = !!globalThis.Proxy\n\nconst convertValue = (evaluation: Evaluation) => {\n  let { value } = evaluation\n\n  try {\n    switch (evaluation.kind.toLowerCase()) {\n      case 'int':\n      case 'number':\n        value = Number(value)\n        break\n      case 'boolean':\n        value = value.toString().toLowerCase() === 'true'\n        break\n      case 'json':\n        value = JSON.parse(value as string)\n        break\n    }\n  } catch (error) {\n    logError(error)\n  }\n\n  return value\n}\n\nconst initialize = (apiKey: string, target: Target, options: Options): Result => {\n  let environment: string\n  let clusterIdentifier: string\n  let eventSource: any\n  let jwtToken: string\n  let metricsSchedulerId: number\n  let metricsCollectorEnabled = true\n  const stopMetricsCollector = () => {\n    metricsCollectorEnabled = false\n  }\n  const startMetricsCollector = () => {\n    metricsCollectorEnabled = true\n  }\n  let metrics: Array<MetricsInfo> = []\n  const eventBus = mitt()\n  const configurations = { ...defaultOptions, ...options }\n  const logDebug = (message: string, ...args: any[]) => {\n    if (configurations.debug) {\n      // tslint:disable-next-line:no-console\n      console.debug(`[FF-SDK] ${message}`, ...args)\n    }\n  }\n  const updateMetrics = (metricsInfo: MetricsInfo) => {\n    if (metricsCollectorEnabled) {\n      const now = Date.now()\n\n      if (now - metricsInfo.lastAccessed > METRICS_VALID_COUNT_INTERVAL) {\n        metricsInfo.count++\n        metricsInfo.lastAccessed = now\n      }\n    }\n  }\n\n  globalThis.onbeforeunload = () => {\n    if (metrics.length && globalThis.localStorage) {\n      stopMetricsCollector()\n      globalThis.localStorage.HARNESS_FF_METRICS = JSON.stringify(metrics)\n      startMetricsCollector()\n    }\n  }\n\n  const authenticate = async (clientID: string, configuration: Options): Promise<string> => {\n    const response = await fetch(`${configuration.baseUrl}/client/auth`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ apiKey: clientID, target })\n    })\n\n    const data: { authToken: string } = await response.json()\n\n    return data.authToken\n  }\n\n  const scheduleSendingMetrics = () => {\n    if (metrics.length) {\n      logDebug('Sending metrics...', { metrics, evaluations })\n      const payload = {\n        metricsData: metrics.map(entry => ({\n          timestamp: Date.now(),\n          count: entry.count,\n          metricsType: 'FFMETRICS',\n          attributes: [\n            {\n              key: 'featureIdentifier',\n              value: entry.featureIdentifier\n            },\n            {\n              key: 'featureName',\n              value: entry.featureIdentifier\n            },\n            {\n              key: 'variationIdentifier',\n              value: entry.variationIdentifier\n            },\n            {\n              key: 'target',\n              value: target.identifier\n            },\n            {\n              key: 'SDK_NAME',\n              value: 'JavaScript'\n            },\n            {\n              key: 'SDK_TYPE',\n              value: 'client'\n            },\n            {\n              key: 'SDK_VERSION',\n              value: SDK_VERSION\n            }\n          ]\n        }))\n      }\n\n      fetch(`${configurations.eventUrl}/metrics/${environment}?cluster=${clusterIdentifier}`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${jwtToken}` },\n        body: JSON.stringify(payload)\n      })\n        .then(() => {\n          metrics = []\n        })\n        .catch(error => {\n          logError(error)\n        })\n        .finally(() => {\n          metricsSchedulerId = window.setTimeout(scheduleSendingMetrics, METRICS_FLUSH_INTERVAL)\n        })\n    } else {\n      metricsSchedulerId = window.setTimeout(scheduleSendingMetrics, METRICS_FLUSH_INTERVAL)\n    }\n  }\n\n  let evaluations: Record<string, Evaluation> = {}\n\n  const creatStorage = function () {\n    return hasProxy\n      ? new Proxy(\n          {},\n          {\n            get(_storage, property) {\n              const _value = _storage[property]\n\n              if (_storage.hasOwnProperty(property)) {\n                const featureValue = _storage[property]\n                // TODO/BUG: This logic to collect metrics will fail when two variations have the same value\n                // Need to find a better way\n                const entry = metrics.find(\n                  _entry => _entry.featureIdentifier === property && featureValue === _entry.featureValue\n                )\n\n                if (entry) {\n                  entry.variationIdentifier = evaluations[property as string]?.identifier || ''\n                  updateMetrics(entry)\n                } else {\n                  metrics.push({\n                    featureIdentifier: property as string,\n                    featureValue,\n                    variationIdentifier: evaluations[property as string]?.identifier || '',\n                    count: metricsCollectorEnabled ? 1 : 0,\n                    lastAccessed: Date.now()\n                  })\n                }\n                logDebug(\n                  'Metrics event: Flag:',\n                  property,\n                  'has been read with value:',\n                  featureValue,\n                  'variationIdentifier:',\n                  evaluations[property as string]?.identifier\n                )\n              }\n\n              return _value\n            }\n          }\n        )\n      : {}\n  }\n\n  let storage: Record<string, any> = creatStorage()\n\n  authenticate(apiKey, configurations)\n    .then((token: string) => {\n      jwtToken = token\n      const decoded: { environment: string, clusterIdentifier: string } = jwt_decode(token)\n\n      logDebug('Authenticated', decoded)\n\n      if (globalThis.localStorage && globalThis.localStorage.HARNESS_FF_METRICS) {\n        try {\n          // metrics = JSON.parse(globalThis.localStorage.HARNESS_FF_METRICS)\n          delete globalThis.localStorage.HARNESS_FF_METRICS\n          logDebug('Picking up metrics from previous session')\n        } catch (error) {}\n      }\n\n      metricsSchedulerId = window.setTimeout(scheduleSendingMetrics, METRICS_FLUSH_INTERVAL)\n\n      environment = decoded.environment\n      clusterIdentifier = decoded.clusterIdentifier\n\n      // When authentication is done, fetch all flags\n      fetchFlags()\n        .then(() => {\n          logDebug('Fetch all flags ok', storage)\n        })\n        .then(() => {\n          startStream() // start stream only after we get all evaluations\n        })\n        .then(() => {\n          logDebug('Event stream ready', { storage })\n          eventBus.emit(Event.READY, storage)\n\n          if (!hasProxy) {\n            Object.keys(storage).forEach(key => {\n              metrics.push({\n                featureIdentifier: key,\n                featureValue: storage[key],\n                variationIdentifier: evaluations[key]?.identifier || '',\n                count: metricsCollectorEnabled ? 1 : 0,\n                lastAccessed: Date.now()\n              })\n            })\n          }\n        })\n        .catch(err => {\n          eventBus.emit(Event.ERROR, err)\n        })\n    })\n    .catch(error => {\n      logError('Authentication error: ', error)\n      eventBus.emit(Event.ERROR, error)\n    })\n\n  const fetchFlags = async () => {\n    try {\n      const res = await fetch(\n        `${configurations.baseUrl}/client/env/${environment}/target/${target.identifier}/evaluations?cluster=${clusterIdentifier}`,\n        {\n          headers: {\n            Authorization: `Bearer ${jwtToken}`\n          }\n        }\n      )\n      const data = await res.json()\n\n      data.forEach((_evaluation: Evaluation) => {\n        const _value = convertValue(_evaluation)\n        storage[_evaluation.flag] = _value\n        evaluations[_evaluation.flag] = { ..._evaluation, value: _value }\n      })\n    } catch (error) {\n      logError('Features fetch operation error: ', error)\n      eventBus.emit(Event.ERROR, error)\n      return error\n    }\n  }\n\n  const fetchFlag = async (identifier: string) => {\n    try {\n      const result = await fetch(\n        `${configurations.baseUrl}/client/env/${environment}/target/${target.identifier}/evaluations/${identifier}?cluster=${clusterIdentifier}`,\n        {\n          headers: {\n            Authorization: `Bearer ${jwtToken}`\n          }\n        }\n      )\n\n      if (result.ok) {\n        const flagInfo: Evaluation = await result.json()\n        const _value = convertValue(flagInfo)\n\n        stopMetricsCollector()\n        storage[identifier] = _value\n        evaluations[identifier] = { ...flagInfo, value: _value }\n        startMetricsCollector()\n\n        eventBus.emit(\n          Event.CHANGED,\n          hasProxy\n            ? new Proxy(flagInfo, {\n                get(_flagInfo, property) {\n                  if (_flagInfo.hasOwnProperty(property) && property === 'value') {\n                    // only track metric when value is read\n                    const featureIdentifier = _flagInfo.flag\n                    const featureValue = flagInfo.value\n                    const entry = metrics.find(\n                      _entry => _entry.featureIdentifier === featureIdentifier && _entry.featureValue === featureValue\n                    )\n\n                    if (entry) {\n                      updateMetrics(entry)\n                      entry.variationIdentifier = evaluations[featureIdentifier]?.identifier || ''\n                    } else {\n                      metrics.push({\n                        featureIdentifier,\n                        featureValue: String(featureValue),\n                        variationIdentifier: evaluations[featureIdentifier].identifier || '',\n                        count: metricsCollectorEnabled ? 1 : 0,\n                        lastAccessed: Date.now()\n                      })\n                    }\n                    logDebug(\n                      'Metrics event: Flag',\n                      property,\n                      'has been read with value via stream update',\n                      featureValue\n                    )\n                  }\n\n                  return property === 'value' ? convertValue(flagInfo) : flagInfo[property]\n                }\n              })\n            : {\n                deleted: flagInfo.deleted,\n                flag: flagInfo.flag,\n                value: convertValue(flagInfo)\n              }\n        )\n\n        if (!hasProxy) {\n          const featureIdentifier = flagInfo.flag\n          const entry = metrics.find(\n            _entry => _entry.featureIdentifier === featureIdentifier && _entry.featureValue === flagInfo.value\n          )\n\n          if (entry) {\n            updateMetrics(entry)\n            entry.variationIdentifier = evaluations[featureIdentifier as string]?.identifier || ''\n          } else {\n            metrics.push({\n              featureIdentifier: featureIdentifier as string,\n              featureValue: String(flagInfo.value),\n              variationIdentifier: evaluations[featureIdentifier].identifier || '',\n              count: metricsCollectorEnabled ? 1 : 0,\n              lastAccessed: Date.now()\n            })\n          }\n        }\n      } else {\n        eventBus.emit(Event.ERROR, result)\n      }\n    } catch (error) {\n      logError('Feature fetch operation error: ', error)\n      eventBus.emit(Event.ERROR, error)\n    }\n  }\n\n  const startStream = () => {\n    // TODO: Implement polling when stream is disabled\n    if (!configurations.streamEnabled) {\n      logDebug('Stream is disabled by configuration. Note: Polling is not yet supported')\n      return\n    }\n    eventSource = new EventSource(`${configurations.baseUrl}/stream`, {\n      headers: {\n        Authorization: `Bearer ${jwtToken}`,\n        'API-Key': apiKey\n      }\n    })\n\n    eventSource.onopen = (event: any) => {\n      logDebug('Stream connected', event)\n      eventBus.emit(Event.CONNECTED)\n    }\n\n    eventSource.onclose = (event: any) => {\n      logDebug('Stream disconnected')\n      eventBus.emit(Event.DISCONNECTED)\n    }\n\n    eventSource.onerror = (event: any) => {\n      logError('Stream has issue', event)\n      eventBus.emit('error', event)\n    }\n\n    eventSource.addEventListener('*', (msg: any) => {\n      const event: StreamEvent = JSON.parse(msg.data)\n\n      logDebug('Received event from stream: ', event)\n\n      switch (event.event) {\n        case 'create':\n          setTimeout(() => fetchFlag(event.identifier), 1000) // Wait a bit before fetching evaluation due to https://harness.atlassian.net/browse/FFM-583\n          break\n        case 'patch':\n          fetchFlag(event.identifier)\n          break\n        case 'delete':\n          delete storage[event.identifier]\n          eventBus.emit(Event.CHANGED, { flag: event.identifier, value: undefined, deleted: true })\n          logDebug('Evaluation deleted', { message: event, storage })\n          // TODO: Delete flag from storage\n          break\n      }\n    })\n  }\n\n  const on = (event: Event, callback: EventCallback): void => eventBus.on(event, callback)\n\n  const off = (event?: Event, callback?: EventCallback): void => {\n    if (event) {\n      eventBus.off(event, callback)\n    } else {\n      close()\n    }\n  }\n\n  const variation = (flag: string, defaultValue: any) => {\n    const value = storage[flag]\n\n    if (!hasProxy && value !== undefined) {\n      const featureValue = value\n      const featureIdentifier = flag\n\n      const entry = metrics.find(\n        _entry => _entry.featureIdentifier === featureIdentifier && _entry.featureValue === featureValue\n      )\n\n      if (entry) {\n        updateMetrics(entry)\n        entry.variationIdentifier = evaluations[featureIdentifier as string]?.identifier || ''\n      } else {\n        metrics.push({\n          featureIdentifier: featureIdentifier as string,\n          featureValue,\n          count: metricsCollectorEnabled ? 1 : 0,\n          variationIdentifier: evaluations[featureIdentifier].identifier || '',\n          lastAccessed: Date.now()\n        })\n      }\n    }\n\n    return value !== undefined ? value : defaultValue\n  }\n\n  const close = () => {\n    logDebug('Closing event stream')\n    storage = creatStorage()\n    evaluations = {}\n    clearTimeout(metricsSchedulerId)\n    eventBus.all.clear()\n    eventSource.close()\n  }\n\n  return { on, off, variation, close }\n}\n\nexport { initialize, Options, Target, StreamEvent, Event, EventCallback, Result, Evaluation, VariationValue }\n", "export interface Target {\n  identifier: string\n  name?: string\n  anonymous?: boolean\n  attributes?: object\n}\n\nexport interface StreamEvent {\n  event: string\n  domain: string\n  identifier: string\n  version: number\n}\n\nexport enum Event {\n  READY = 'ready',\n  CONNECTED = 'connected',\n  DISCONNECTED = 'disconnected',\n  RECONNECTED = 'reconnected',\n  CHANGED = 'changed',\n  ERROR = 'error'\n}\n\nexport type VariationValue = boolean | string | number | object | undefined\n\nexport interface Evaluation {\n  flag: string          // Feature flag identifier\n  identifier: string    // variation identifier\n  value: VariationValue // variation value\n  kind: string          // boolean | json | string | int\n  deleted?: boolean     // mark that feature flag is deleted\n}\n\nexport type EventCallback = (event?: Evaluation[] | Error) => void\n\nexport interface Result {\n  on: (event: Event, callback: EventCallback) => void\n  off: (event: Event, callback: EventCallback) => void\n  variation: (identifier: string, defaultValue: any) => VariationValue\n  close: () => void\n}\n\nexport interface Options {\n  baseUrl?: string\n  eventUrl?: string\n  streamEnabled?: boolean\n  allAttributesPrivate?: boolean\n  privateAttributeNames?: string[]\n  debug?: boolean\n}\n\nexport interface MetricsInfo {\n  featureIdentifier: string;\n  featureValue: any\n  variationIdentifier: string;\n  count: number\n  lastAccessed: number\n}\n", "import { Options } from './types'\n\nexport const defaultOptions: Options = {\n  debug: false,\n  baseUrl: 'https://config.feature-flags.uat.harness.io/api/1.0',\n  eventUrl: 'https://event.feature-flags.uat.harness.io/api/1.0',\n  streamEnabled: true,\n  allAttributesPrivate: false,\n  privateAttributeNames: []\n}\n\n// tslint:disable-next-line:no-console\nexport const logError = (message: string, ...args: any[]) => console.error(`[FF-SDK] ${message}`, ...args)\n\nexport const METRICS_FLUSH_INTERVAL = 30 * 1000 // Flush metrics every 30 seconds"],
  "mappings": "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",
  "names": []
}
