import M from"jwt-decode";import U from"mitt";import{EventSourcePolyfill as _}from"event-source-polyfill";var l;(function(n){n.READY="ready",n.CONNECTED="connected",n.DISCONNECTED="disconnected",n.RECONNECTED="reconnected",n.CHANGED="changed",n.ERROR="error"})(l||(l={}));var F={debug:!1,baseUrl:"https://config.feature-flags.uat.harness.io/api/1.0",eventUrl:"https://event.feature-flags.uat.harness.io/api/1.0",streamEnabled:!0,allAttributesPrivate:!1,privateAttributeNames:[]},g=(n,...o)=>console.error(`[FF-SDK] ${n}`,...o),T=30*1e3;var R=globalThis.fetch,H=_,p=!!globalThis.Proxy,N=n=>{let{value:o}=n;try{switch(n.kind.toLowerCase()){case"int":case"number":o=Number(o);break;case"boolean":o=o.toLocaleString()==="true";break;case"json":o=JSON.parse(o);break}}catch(E){g(E)}return o},J=(n,o,E)=>{let S,m,b,y,r=[],s=U(),h={...F,...E},c=(t,...e)=>{h.debug&&console.debug(`[FF-SDK] ${t}`,...e)};globalThis.onbeforeunload=()=>{r.length&&globalThis.localStorage&&(globalThis.localStorage.HARNESS_FF_METRICS=JSON.stringify(r))};let w=async(t,e)=>(await(await R(`${e.baseUrl}/client/auth`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({apiKey:t,target:o})})).json()).authToken,C=()=>{if(r.length){c("Sending metrics...",r);let t={metricsData:r.map(e=>({timestamp:Date.now(),count:e.count,metricsType:"FFMETRICS",attributes:[{key:"featureIdentifier",value:e.featureIdentifier},{key:"featureName",value:e.featureIdentifier},{key:"featureValue",value:String(e.featureValue)},{key:"target",value:o.identifier},{key:"SDK_NAME",value:"JavaScript"},{key:"SDK_TYPE",value:"client"}]}))};R(`${E.eventUrl}/metrics/${S}`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${b}`},body:JSON.stringify(t)}).then(()=>{r=[]}).catch(e=>{g(e)}).finally(()=>{y=setTimeout(C,T)})}else y=setTimeout(C,T)},O=function(){return p?new Proxy({},{get(t,e){if(t.hasOwnProperty(e)){let a=t[e],u=r.find(i=>i.featureIdentifier===e&&i.featureValue===a);u?u.count++:r.push({featureIdentifier:e,featureValue:a,count:1}),c("Metrics event: Flag",e,"has been read with value",a)}return t[e]}}):{}},f=O();w(n,h).then(t=>{b=t;let e=M(t);if(c("Authenticated",e),globalThis.localStorage&&globalThis.localStorage.HARNESS_FF_METRICS)try{r=JSON.parse(globalThis.localStorage.HARNESS_FF_METRICS),delete globalThis.localStorage.HARNESS_FF_METRICS,c("Picking up metrics from previous session")}catch(a){}y=setTimeout(C,T),S=e.environment,D().then(()=>{c("Fetch all flags ok",f)}).then(()=>{$()}).then(()=>{c("Event stream ready",{storage:f}),s.emit(l.READY,f),p||Object.keys(f).forEach(a=>{r.push({featureIdentifier:a,featureValue:f[a],count:1})})}).catch(a=>{s.emit(l.ERROR,a)})}).catch(t=>{g("Authentication error: ",t),s.emit(l.ERROR,t)});let D=async()=>{try{(await(await R(`${h.baseUrl}/client/env/${S}/target/${o.identifier}/evaluations`,{headers:{Authorization:`Bearer ${b}`}})).json()).forEach(a=>{f[a.flag]=N(a)})}catch(t){return g("Features fetch operation error: ",t),s.emit(l.ERROR,t),t}},k=async t=>{try{let e=await R(`${h.baseUrl}/client/env/${S}/target/${o.identifier}/evaluations/${t}`,{headers:{Authorization:`Bearer ${b}`}});if(e.ok){let a=await e.json();if(f[t]=N(a),s.emit(l.CHANGED,p?new Proxy(a,{get(u,i){if(u.hasOwnProperty(i)&&i==="value"){let d=u.flag,v=a.value,V=r.find(A=>A.featureIdentifier===d&&A.featureValue===v);V?V.count++:r.push({featureIdentifier:i,featureValue:String(v),count:1}),c("Metrics event: Flag",i,"has been read with value via stream update",v)}return i==="value"?N(a):a[i]}}):{deleted:a.deleted,flag:a.flag,value:N(a)}),!p){let u=a.flag,i=r.find(d=>d.featureIdentifier===u&&d.featureValue===a.value);i?i.count++:r.push({featureIdentifier:u,featureValue:String(a.value),count:1})}}else s.emit(l.ERROR,e)}catch(e){g("Feature fetch operation error: ",e),s.emit(l.ERROR,e)}},$=()=>{if(!h.streamEnabled){c("Stream is disabled by configuration. Note: Polling is not yet supported");return}m=new H(`${h.baseUrl}/stream`,{headers:{Authorization:`Bearer ${b}`,"API-Key":n}}),m.onopen=t=>{c("Stream connected",t),s.emit(l.CONNECTED)},m.onclose=t=>{c("Stream disconnected"),s.emit(l.DISCONNECTED)},m.onerror=t=>{g("Stream has issue",t),s.emit("error",t)},m.addEventListener("*",t=>{let e=JSON.parse(t.data);switch(c("Received event from stream: ",e),e.event){case"create":setTimeout(()=>k(e.identifier),1e3);break;case"patch":k(e.identifier);break;case"delete":delete f[e.identifier],s.emit(l.CHANGED,{flag:e.identifier,value:void 0,deleted:!0}),c("Evaluation deleted",{message:e,storage:f});break}})},x=(t,e)=>s.on(t,e),P=(t,e)=>{t?s.off(t,e):I()},j=(t,e)=>{let a=f[t];if(!p&&a!==void 0){let u=a,i=t,d=r.find(v=>v.featureIdentifier===i&&v.featureValue===u);d?d.count++:r.push({featureIdentifier:i,featureValue:u,count:1})}return a!==void 0?a:e},I=()=>{c("Closing event stream"),f=O(),clearTimeout(y),s.all.clear(),m.close()};return{on:x,off:P,variation:j,close:I}};export{l as Event,J as initialize};
//# sourceMappingURL=sdk.esm.js.map
